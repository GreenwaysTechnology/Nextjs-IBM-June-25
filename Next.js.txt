				  Next.js
.............................................................................................

Software Req:

1.Node.js
2.VSCODE

Pre Knowledge:

1.JavaScript
2.React fundamentals

What you are going to learn?

1.Next.js UI development
2.REST api development
3.Database Programming Using Prisma ORM Framework
4.GraphQL with Apollo Framework
5.Connecting Next.js with Apollo Framework
............................................................................................
			Next js 
....................................................................................
What is Next?
	 Next is a flexible React framework that gives you building blocks to create fast "web applications".

What is React?
         React is JavaScript lib to build "Single Page Web applications"/SPA 

What is web app?

  Type of distributed app, deployed at server , accessed over network(internet) vi various network protocols like http,  tcp, smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Response would be document.
=>HTML

other responses types
XML,JSON, Documents, images, videos.........

What is web and why it was created?

  Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser, launched in 1992.
The first web server is NeXT computer
The first web page , launched http://info.cern.ch/hypertext/WWW/TheProject.html


Technology stack:
................
1.HTML
2.Webserver - Next Computer
3.LineMode Web Browser
4.HTTP protocol.
.......................................................................................................................................................

Types of Web application:

1.Static web applications - 1989 to 1995

    Hard coded html pages, Prepared html pages kept at server, the web server will send those html pages to clients - browsers

Do you think Static web applications still exits?
  Yes!, but we don't prepare the html pages by hand.. rather we ask the server to prepare..


2.Dynamic Content generation application(1996 to till date)

  After 1995, many people thought that how we can use web for biz information system

 How to share biz information via internet?
   Generally biz data is stored in databases , how to embed database data into html pages.

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients.


Web server core design to get client request and send html response to the client.

Along with web server, something was introduced called "Programming language runtime"

Tech stacks:

1.CGI With C language and Perl script.
2.Java Servlets and JSP
3.Active Server pages - ASP
4.PHP

3.Web services-1998 to till date

 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and receive data because html is just   user interface document language.

 We need , data to be exchanged, that's where new data model was created called 'XML'
xml based web apps called web services.

SOAP protocol was created to transfer XML based documents "SOAP based webservices"

After 2005 SOAP based web services, started failing due to mobile computing.

New Web services  were designed called "RestFull Web services"

Restfull web services were used to build any type of data formats like json,xml,pdf,html etc...

4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using JavaScript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, JavaScript.

Frameworks build based on SPA

1.Angular js |Angular
2.react js
3.vue js

........................................................................................................................................................
						React as SPA lib
........................................................................................................................................................

React.js was created by Facebook , in order to build SPA applications for browsers.

Advantages of SPA:

1.Pages are created  at client side, so server load is completely removed
2.SPA reduces the lot of physical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
...........................

Pure client SPAs are problematic when the app is sensitive to SEO and 
Time-to concept ,This is because the browser will receive a large empty HTML page and has to wait until the JavaScript is loaded before rendering any thing.

To solve SEO Problems, new Technology was created called "SSR" - Server Side Rendering

..................................................................................
			Server side Rendering
...................................................................................

I need SEO but at the same time, i want to use SPA as well.
 
We provide first class api to "render"  an SPA app into HTML strings on the server.


This allows server to send back already rendered HTML, allowing end users to see the content immediately while the JavaScript is being downloaded.

Hydration:
  This process is called "hydration", the app is compiled at server side and sent to the client which will be  interactive.

....................................................................................................................................................			           				Rendering Types
.....................................................................................................................................................

What is Rendering?
   Render means preparation, HTML Page preparation...


Rendering Types:
1.CSR- Client side Rendering.
   HTML Pages are prepared at client side - Pure SPA Applications
2.SSR  -Server Side rendering
   HTML Pages are prepared at server side - Dynamic Content Generation applications.

Based on these rendering type, we can classify other rendering

1.Universal rendering /Hybrid Rendering
  Server + Client side , combing both rendering 

2.Full SSR and Partial SSR
    Partial SSR is nothing but only "index.html" is compiled at server , rest of the application is rendered at client side.
   Full SSR is nothing but "index.html" and other pages are compiled at server....
		
.....................................................................................
		      When Rendering can happen
 		    (when html pages are prepared)
....................................................................................
1.Request time
2.Build time

1.Request time :
 When user types url 

  http://www.example.com/product--------------->Server Receives Request----Prepares Page--send   that page to client.
 Technologies : jsp,asp,php

2.Build time
    Build is nothing but, preparing app for production.. before hosting we have to prepare the   app
  During build phase, we can prepare html pages/render html pages 


SSG -  Static Site Generations:
...............................

Building web sites/apps during build phase is called SSG.

Why SSG?
  Super fast page access

Based On SSG , There is specification is available "JAM Stack"

Data changes rapidly , we need to enable request time page preparation.
.....................................................................................
			    SSR (request time) + SSG (build time)

During build process, we have to enable SSG, during runtime not for all pages we need to enable SSR (Request Time page Preparation)

....................................................
			ISR - Incremental Static Rendering
.....................................................................................

SSG - Build time or ahead of time
SSR - Request time

ISR = SSG + SSR - Build time + request time 
.....................................................................................
				What is Next.js?

Next js is a framework that helps to build web apps of all types
  
 you can build Full SSR apps..
 you can build SSR With Request time
 you can build SSG with Build time -  JAM Stacks
 you can build SSR with CSR  - Server + SPA - Hybrid rendering
 you can build rest apis also - Web services

         "You cant build pure SPA apps like react with redux"

Using Next you can build 
     Pure server side apps with database access, other external api access.....

.....................................................................................
	               Next js UI layer - Next JS APP architecture
.....................................................................................
Next js uses "react core features" to build UI layer...

React core features:
1.React component driven
2.React uses data mutation techniques like props and state
3.React uses event listeners for interactions
4.React hooks

Next.js tech stack:

1.React as ui layer
2.Next does not recommend to use "redux"
3.Next uses api layer- rest api development
4.Next can talk to any database via orm frameworks...

.....................................................................................
			Next js framework and Runtime Architecture
.....................................................................................

Next js uses "Rust based build system" where as react uses web pack build ....

What is Rust?
 It is programming language, used to build Nestjs apps. Next core engine is written in Rust only.

Next.js Compiler:
..................
 Next js Compiler is written using RUST Using SWC (Speedy Web Compiler).
https://swc.rs/docs/getting-started

SWC allows next js to transform and minify the js code for production. This replaces babel.

SWC is 20x faster than Babel, it is embedded inside next js

Turbo pack:
 Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. Turbopack can be used in Next.js in both the pages and app directories for faster local development
....................................................................................
		NEXT JS Getting Started
.....................................................................................

How to install next js and how to create app?

System Req:

1.Node.js 18.18 or later
2.OS - any os
3.vs code.

Installing/Create next app:
..........................

There are two ways :

1.automatic way


   We recommend starting a new Next.js app using create-next-app, which sets up everything automatically for you. To create a project, run:

npx create-next-app@latest

2.manual way

 Just create folder and app structure your self and install packages

 To manually create a new Next.js app, install the required packages:
 npm install next@latest react@latest react-dom@latest

G:\IBM\2025\June\NextJs>npx create-next-app@latest
√ What is your project named? ... hello-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2025\June\NextJs\hello-app.

.............................................................................................
			        Exploring Project Structure
..............................................................................................

package.json
{
  "name": "hello-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.1.6"
  }
}

next.config.mjs

/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

Common js :

src/greet.js

exports.hello = 'hello'


src/index.js
const res = require('./greet')

console.log(res.hello)

here "require" and exports are commonjs keywords, which is supported by by default in node.js

E6 modules:
 export,export default,import - keywords

can we use these keywords inside node?

Solution:
1.you have to convert es6 module code into commonjs , so that node can understand

2.you have to configure package.json 
   "type:module"
3.you have to save file with "fileName.mjs" extension.


eg:
{
  "name": "mynodeapp",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "type":"module",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}
src/greet.js

// exports.hello = 'hello'

export const hello = 'hello'

src/index.js
// const res = require('./greet')

// console.log(res.hello)
import { hello } from "./greet.js";

console.log(hello)

..................................................................
You can use .mjs extension to identify the file is es 6 module.

src/greet.mjs

export const hello = 'hello'


src/index.js
import { hello } from "./greet.mjs";

console.log(hello)
..............................................................................................

Compiler Config:
............................
jsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}	
.............................................................................................
Folders:

public
 Stores static assets such as images,fonts,documents
 public dir are accessed inside code using the base URL "/"

src:
  Root source code folder

src/app:
   It is root folder where all source code of the next will go.

This is where all application code will go..

layout.js
page.js
global.css
page.module.css

.....................................................................................
How to run next app?

dev, build and prod

dev mode:

>npm run dev


............................................................................................................................................................
.........................................................................................................................................................
		               Next.js Application Architecture
........................................................................................................................................................
               Next.js app is server side app, so for each web page ,the html page is created.
		          "Next App is conventional over Configuration based"

conventional over configuration is a software design principle that reduces the need for explicit configuration by following sensible defaults.
file names and folder names are standard based.
filenames are predefined...like page.js , layout.js

.....................................................................................
			 React core features inside next js
.....................................................................................
1.Component:
  In react every thing is component, in next also the component driven arch is followed.

2.Props
    In react data is passed to the component via props.
    Components are created in a configurable way..

Types of Props:

1.Data as prop

function User(props){
   return <div>
		<h1>{props.id}</h1>
  <div>
}

   <User id={1} />

2.State as Prop -Dynamic Prop

  function User(){
    const [id,setId] = useState(1)
    return <UserDetails id={id} />
  }

3.function as Prop- Listeners as Prop

  function User(){
    const [id,setId] = useState(1)
    return <UserDetails setId={setId} />
  }

4.Component as Prop

Component as Prop syntax we use heavily in Next.js

Component Rendering:

function Tab(props){
   return <> {props.children} </>
}

<Tab/> - Self Closing
  This component has no children

<Tab>
    <Grid/> -  Component as Prop
<Tab>
......................................................................***********************************..................
.....................................................................................
			 Every thing is component  in Next.js
....................................................................................

Page Component: - page.js
  It is place holder component which displays ui.

Layout Component:
  It is container component which holds Page Component


   layout - parent
	  ------------------------------
          |                             |
                      Page -child |
          |                             |
          |                             |
          |                             |
           -----------------------------

<Layout>
   <Page/>
</Layout>

How to declare components?

 1.every component must be "functional component" - No Class Component.
 2.every in built component (page,layout...)  must be exported using "export default" only.
 3.Every Next application must have "root layout" src/app/layout.js
 4.Every Next application may have  "home/landing page" src/app/page.js
 5.Component Name can be any thing like HomePage,Home,MyHomePage,MyLayout etc..

How to create Page and layout Components ?

src/page.js

function Home() {
  //you must return jsx 
  return <div>
    <h1>Home Page</h1>
  </div>
}

export default Home;

src/app/layout.js
export default function RootLayout(props) {
    return <html lang="en">
        <body>
            {props.children}
        </body>
    </html>
}

								Routing
.............................................................................................................................................................

Routing is nothing but mapping resources against url.

Types of Routing:

1.page routing
    It is old form of routing pattern, now it is not used
   page routing was available before next.js version 12

2.app routing
    It is modern form of routing pattern, now it is heavily used
    app routing has been available from next.js version 13 onwards

Routing is enabled by mapping "folder" against url
.............................................................................................
			  Nested Routing and Segments
.............................................................................................


G:\IBM\2025\June\NextJs>npx create-next-app@latest
√ What is your project named? ... core-routing
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2025\June\NextJs\core-routing.

...........................................................................................................................................................
							Nested Folders and Routing
..........................................................................................................................................................

src/app/welcome/page.js

export default function WelcomePage(){
    return <h1>Welcome Page</h1>
}

http://localhost:3000/welcome -----> it will show page.js content of welcome/page.js

src/app/about/page.js

export default function About(){
    return <h2>About</h2>
}
http://localhost:3000/about - it will show page.js and content of about/page.js

Nested Layout:
  
src/app/layout.js - Root Layout.

 Every Next app must have one single root layout.	

src/app/welcome/layout.js  -Nested layout.
//nested layout.

export default function WelcomeLayout({ children }) {
    return <div id="welcome layout">
        {children}
    </div>
}

Note:
 inside nested folder, layout.js is optional but inside root folder layout.js is required
 page.js is required for every folder.

.............................................................................................................................................................
				  Deep Nesting
............................................................................................................................................................

Dashboard:

src/app/dashboard/layout.js
export default function DashboardLayout({ children }) {
    return <div id="dashboardLayout">
        {children}
    </div>
}
src/app/dashboard/page.js
export default function Dashboard(){
    return <h1>Dashboard Page</h1>
}

src/app/dashboard/settings/layout.js
export default function SettingsLayout({ children }) {
    return <div id="settingsLayout">
        {children}
    </div>
}
src/app/dashboard/settings/page.js
export default function Settings() {
    return <>
        <h1> Settings</h1>
    </>
}

src/app/dashboard/settings/password/layout.js
export default function PasswordLayout({ children }) {
    return <div id="passwordLayout">
        {children}
    </div>
}

src/app/dashboard/settings/password/page.js
export default function Password(){
    return <h2>Password Page</h2>
}
..............................................................................................................................................................
		Folder is created what if the page.js is not created - not-found.js
...............................................................................................................................................................
eg:

src/app/profile

http://localhost:3000/profile

404
This page could not be found.

if there is no page.js , then next will show the error page automatically which is mapped against not-found.js.

if you dont want default error page and its content, then you can override "not-found.js"

src/app/not-found.js
export default function NotFound() {
    return <h1>Oops,Something went Wrong</h1>
}

..........................................................................................................................................................
						 Public Access Route
if you have different name other than page.js, it will not be available for public access.

app/settings/config.js

http://localhost:3000/settings/config - It will throw error..
............................................................................................................................................................

....................................................................................................................................................
		 			Component Driven Archiecture
....................................................................................................................................................

Layout is container, Page is mapped against route segment, which displays UI.

Can Page Hold other Components?

    Layout
          | 
       Page
            |
 UserProfile
     |
    UserList
      |
      UserItem
G:\IBM\2025\June\NextJs>npx create-next-app@latest
√ What is your project named? ... components-app
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2025\June\NextJs\components-app.

....................................................................................................................................................
		 			Component Driven Archiecture
....................................................................................................................................................

Layout is container, Page is mapped against route segment, which displays UI.

Can Page Hold other Components?

    Layout
          | 
       Page
            |
 UserProfile
     |
    UserList
      |
      UserItem
G:\IBM\2025\May\nextjs>npx create-next-app@latest
√ What is your project named? ... next-components
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2025\May\nextjs\next-components.

Co-location:

     In addition to special files, you have the option to colocate your own files (e.g. components, styles, tests, etc) inside folders in the app directory.

src/app/profile/components/ProfileList.jsx

export default function ProfileList(props){

    return <ul>
          {
            props.data.map(profile=>{
                return <li key={profile.id}>
                    <span>{profile.name}</span>
                </li>
            })
          }
    </ul>
}

src/app/profile/components/Profile.jsx

//import alises syntax from Next.js
import { PROFILES } from "@/app/mock-data/profiles";
// import { PROFILES } from "../../mock-data/profiles";
// import ProfileList from "./ProfileList";
import ProfileList from '@/app/profile/components/ProfileList'

export function Profile() {
    return <>
        <ProfileList data={PROFILES} />
    </>
}

src/app/profile/page.js
// import { Profile } from "@/app/pcomponents/Profile"
import { Profile } from '@/app/profile/components/Profile'

export default function ProfilePage() {
    return <div>
        <Profile />
    </div>
}

src/app/profile/layout.js

export default function ProfileLayout({children}){
    return <div>
         {children}
    </div>
}

Lab:

 Create Posts Components and list all Posts
...

.............................................................................................
			     Component Types and Rendering Types
.....................................................................................

Rendering is nothing but page preparation (html creation).

How to create html and where to create Html?

Where:
 rendering can take place in the server or on the client.

When:
  At Server side:
   It can happen either ahead of time at build time.
   or on every Request at runtime.

With next js , two types of rendering methods are available.

1.Server-side rendering
   1.0. Request time
   1.1. Static site Generation - build time
   1.2. ISR - Incremental Static rendering - first Build time and later runtime.

2.Client-side Rendering
   Preparing portion of page at client side , which is similar to SPA Apps.

Component types:
 Based on Rendering, we can classify the component into two category.

1.Server Component
   Server components are rendered at server side
2.Client components
   Clients components are rendered at client side

      By default all components are "Server Rendered Components"

   page,layouts,templates,notfound,loading,default all are server components only

Even When create custom components

export default function Greet(props) {
     return <>
        <h1>{props.message}</h1>
     </>
}
.....................................................................................
			 	Client Component
....................................................................................


Generally React application is component driven....

Component which may have logic to interact with user like button clicks,typing,animations,data fetch at client side,hooks, any dom manipulation......

The components can be co-located..

Client components allow us to write interactive UI that is prendered on the server and can use client javascript to run in the browser.

Advantages of client Rendering:

1.Interactivity
   Client components uses "state,effects,event listener" , meaning they can provide immediate feedback to the user and update the UI.

2.Browser APIs:
    Client components have access the browser apis like Storage,geo location....


src/app/review/components/review.jsx

import { useState } from "react"

const Review = props => {
    const [like, setLike] = useState(0)
    return <div>
            <h1>Like {like}</h1>
    </div>
}
export { Review }

Ecmascript file had an error
> 1 | import { useState } from "react"
    |          ^^^^^^^^
  2 |
  3 | const Review = props => {
  4 |     const [like, setLike] = useState(0)

You're importing a component that needs `useState`. This React hook only works in a client component. To fix, mark the file (or its parent) with the `"use client"` directive.

 Learn more: https://nextjs.org/docs/app/building-your-application/rendering/client-components

Why this error?

If any component having "hooks,listners,state",then it cant be compiled at server, now need to tell to the next js compiler, you have to compile or render this code in client side.

How to tell?
 we have to use a directive.

Directive is instruction to the compiler.

"use client" - directive

eg:
src/app/review/components/review.jsx

'use client'

import { useState } from "react"
const Review = props => {
    const [like, setLike] = useState(0)
    return <div>
        <h1>Like {like}</h1>
        <button onClick={() => {
            setLike(like + 1)
        }}>+</button>
    </div>
}
export { Review }

src/app/review/page.js
import { Review } from "./components/Review";

export default function ReviewPage(){
    return <div>
        <Review/>
    </div>
}

How to know the client component?

if component has 

1.useState hook
2.Any listener
3.useEffect hook
4.Browser apis
5.state declaration

Task:
  CURD operation using Array:

Solution:
'use client'

import { useState } from "react"

export default function Post(props) {
    const [posts, setPosts] = useState([
        { id: 1, title: 'Post 1', body: 'this is first Post' },
        { id: 2, title: 'Post 2', body: 'this is second Post' }
    ])
    //To handle submitt button either add or update
    const [isEditing, setIsEditing] = useState(false)

    //To handle form : to add new post into list
    const [form, setForm] = useState({ title: '', body: '', id: null })

    //Listeners : To save or update Post
    const handleSubmit = (e) => {
        e.preventDefault()
        isEditing ? updatePost() : addPost()
    }
    //
    const updatePost = () => {
        //array update
        setPosts(posts.map(post => (post.id === form.id ? form : post)))
        //Reset/clear the form
        setForm({ title: '', body: '', id: null })
        //reset add 
        setIsEditing(false)
    }
    const addPost = () => {
        //new Post object
        const newPost = { id: Date.now(), title: form.title, body: form.body }
        //add post into posts array
        setPosts([...posts, newPost])
        //Reset/clear the form
        setForm({ title: '', body: '', id: null })
    }

    //Edit Post
    const handleEdit = (post) => {
        console.log(post)
        //load into form fields
        setForm({ title: post.title, body: post.body, id: post.id })
        //reset Flag from add to edit
        setIsEditing(true)
    }
    //Delete Post
    const handleDelete = id => {
        setPosts(posts.filter(post => post.id !== id))
    }

    return <div>
        {/* To add new post or edit existing */}
        {/* Todo: Remove this after completing */}
        {/* {JSON.stringify(form)} */}
        <form onSubmit={handleSubmit}>
            <div>
                <input type="text" required onChange={e => setForm({ ...form, title: e.target.value })} value={form.title} placeholder="Title" />
            </div>
            <div>
                <textarea placeholder="Body" required onChange={e => setForm({ ...form, body: e.target.value })} value={form.body} />
            </div>
            <div>
                <button type="submit">{isEditing ? 'Update' : 'Add'} Post</button>
            </div>
        </form>

        {/* List existing Posts */}
        <ul>
            {posts.map(post => {
                return <li key={post.id}>
                    <h2>{post.title}</h2>
                    <p>{post.body}</p>
                    <button onClick={(e) => {
                        handleEdit(post)
                    }}>Edit</button>
                    <button onClick={(e) => {
                        handleDelete(post.id)
                    }}>Delete</button>
                </li>
            })}
        </ul>
    </div>
}
...................................................................................................................................................
							..............................................................................................
				Patterns for client and server components
.............................................................................................

1.Server component uses another Server Component
   inside layout.js we use page.js
   inside page.js we use about.jsx 

2.Server component uses client component

3.Client component uses another server component

4.Client component uses another client component


2.Server component uses client component

Server:

src/app/reviews/page.js
import { Like } from './components/like'

export default function ReviewPage() {
    return <div>
        <h1>Review Page</h1>
        <Like />
    </div>
}

Client:
src/app/reviews/components/likes.jsx

'use client'
import { useState } from "react"
export const Like = props => {
    const [value, setValue] = useState(0)

    const onLike = () => {
        setValue(value + 1)
    }
    return <>
        <h1>Like {value}</h1>
        <button onClick={onLike}>Like</button>
    </>
}

Note:
 if server uses client, the client component must be marked with "use client" directive


...........................................................
		2.Client component uses another server component
.........................................................................................................................................................

//server component
src/app/reviews/components/comments.jsx
//server component
export const Comments = ()=> {
    return <>
     <h1>Comments  Server Compoent</h1>
    </>
}

//client component
src/app/reviews/components/dislike.jsx


'use client'

import { useState } from "react"
import { Comments } from "./comments"

export const Dislike = ()=> {
 const [value,setValue]= useState(0)
 return <>
     <h1>Dislike-Client Component</h1>
      <h2>Value  {value}</h2>
      {/* Server component */}
      <Comments/>
 </>

}

src/app/reviews/page.js
import { Dislike } from './components/dislike'

export default function ReviewPage() {
    return <div>
        <h1>Review Page</h1>
        <Dislike/>
    </div>
}

 if client uses another server component,"server component automatically becomes client component"

                 When we use this pattern we loose server rendering.

In the above code comments component runs in the client only.


What if "client uses server component" but at the same time, i dont want to loose server rendering feature?

Solution:

  Pass Server Component as Prop to Child  component.

Server:
src/app/client/components/myserver.jsx
export default function MyServer(){
    return <>
        <h1>Server Compoent</h1>
    </>
}

Client
src/app/client/components/myclient.jsx
'use client'

export const MyClient = (props) => {

    return <div>
        <h1>Client Component</h1>
        {props.children}
    </div>
}


Page
src/app/client/page.js
import { MyClient } from "./components/myclient";
import MyServer from "./components/myserver";

export default function ClientComponentPage(){
    return <div>
            <MyClient>
                {/* Pass server as prop */}
                <MyServer/>
            </MyClient>
    </div>
}
....................................................................................
		3.Client Compoent uses another client Component
.....................................................................................


Page:
src/app/counter/page.js
import Counter from "./components/counter";

export default function CounterPage(){
    return <div>
        <h1>Counter Page</h1>
        <Counter/>
    </div>
}

src/app/counter/counter.jsx

'use client'

import Increment from "./increment"

export default function Counter() {

    return <>
        <h1>Counter Component</h1>
        <Increment/>
    </>
}

src/app/counter/increment.jsx


'use client'
import { useState } from "react"

export default function Increment() {
  const [value,setValue] = useState(0)
    return <>
        <h1>Increment Value {value}</h1>
    </>
}

Note :

If client component uses another client component, that another client component no need to use 'use client' directive.

Note :

If client component uses another client component, that another client component no need to use 'use client' directive.

This would be very useful when we use thrid party ui components into next js
.....................................................................................

Eg:
How to use react carbon lib

Steps:

1.npm install @carbon/react

2.create client component

src/app/clientcomponents/MyButton.jsx
'use client'

import { Button } from '@carbon/react';

export function MyButton() {
    return <>
        <Button kind="danger">
            Button
        </Button>

        <Button kind="danger--tertiary">
            Tertiary Danger Button
        </Button>

        <Button kind="danger--ghost">
            Ghost Danger Button
        </Button>
    </>
}

3.Use that client component inside another client component or server component

import { Counter } from "./components/counter";
import { MyButton } from "./components/MyButton";

export default function CounterPage(){
    return <div>
        <Counter/>
        <hr/>
        <MyButton/>
    </div>
}

Task:
 Build simple shopping cart using client components

Features
1.Loads cart items from localStorage when page loads
2.Add new Items to the cart dynamically
3.Removes items with a delete button
4.saves the cart back to the localStorage whenever it changes
5.persist data even after page refresh.

........................*******************.................................................
		  Advanced Routing - Linking and Navigation
..............................................................................................

There are four ways to navigate between routes in Next.js

- Using the <Link> Component (Client Component)
- Using useRouter hook (client Component)
- Using the native browser History API (client)
- Using redirect function (Server component)

Navigation can happen  in two places

1.Server side redirection/navigation
   Redirection is controlled by Server

2.Client Side Redirection/Navigation
   Redirction is controlled by browser

Server Redirection:
1.redirect function
2.permantRedirect function
3.routeConfig file
4.API redirections - NextReponse.redirect


Client Side Naviation:
1.Link componet
2.useRouter Hook
3.Browser Native History API.

G:\IBM\2025\June\NextJs>npx create-next-app@latest
√ What is your project named? ... linking-navigation
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2025\June\NextJs\linking-navigation.


Link Component:

 Link is react component that extends the HTML <a> element to provide client side navigation between routes.

 Link component has lot of properties
 1.href
 2.replace
 3.scroll
 4.prefech

 href property
 value of href can be string or object

href="/route"
href={{pathname:'/route'}}

eg:

src/app/components/navbar.jsx
import Link from "next/link";

export default function NavBar() {

    return <nav>
        <ul>
            <li><Link href={{ pathname: '/about' }}>About</Link></li>
            <li><Link href={{ pathname: '/clients' }}>Clients</Link></li>
        </ul>
    </nav>
}

src/app/layout.jsx
import NavBar from "@/app/components/navbar";
import "./globals.css";

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
          <NavBar/>
        <hr />
        {children}
        <footer>
          <p>This is footer</p>
        </footer>
      </body>
    </html>
  );
}
.....................................................................................
					Active Links
.......	..............................................................................

How to enable active link feature?

you can use hook "usePathname()" to determine if link is active or not.

For example to add a css class to the active link, you can check the current pathname matches the of the link.

Syntax:
import {usePathname} from 'next/navigation'

const pathname = usePathname()

Link className={`link ${pathname=== '/' ? 'active' : ''}`}>Home</Link> 


src/app/layout.js
import { Inter } from "next/font/google";
import Link from "next/link";
import { usePathname } from 'next/navigation'

// import "./globals.css";
import './link.css'

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {

  const pathname = usePathname()

  return (
    <html lang="en">
      <body className={inter.className}>
        <div id="header">
          <h1>Header</h1>
          <hr />
          {/* Nav Bar */}
          <nav>
            <ul>
              <li>
                <Link className={`link ${pathname === '/' ? 'active' : ''}`} href={{ pathname: '/' }}>Home</Link> </li>
              <li>
                <Link href={{ pathname: '/about' }}>About</Link>
              </li>
              <li>
                <Link href={{ pathname: '/products' }}>Products</Link>
              </li>
              <li>
                <Link href={{ pathname: '/customercare' }}>Customer Care</Link>
              </li>
            </ul>

          </nav>
        </div>
        <div id="footer">
          <h3>footer</h3>
        </div>
      </body>
    </html>
  );
}

After running , you will get error, 

Error: 
  × You're importing a component that needs usePathname. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.
  │ Learn more: https://nextjs.org/docs/getting-started/react-essentials
  │ 
  │ 
   ╭─[G:\IBM\2024\June\NextJs\linking-navigation\src\app\layout.js:1:1]
 1 │ import { Inter } from "next/font/google";
 2 │ import Link from "next/link";
 3 │ import { usePathname } from 'next/navigation'
   ·          ───────────
 4 │ 
 5 │ // import "./globals.css";
 6 │ import './link.css'

Because usePathname is a hooks works in client component only.

....................................................................................

Solution:

Create client component , use usePathName hook.

src/app/components/Navbar.jsx

'use client'
import Link from "next/link";
import { usePathname } from 'next/navigation'
import '../link.css'

export function Links() {
    const pathname = usePathname()

    return <nav>
        <ul>
            <li>
                <Link className={`link ${pathname === '/' ? 'active' : ''}`} href={{ pathname: '/' }}>Home</Link> </li>
            <li>
                <Link className={`link ${pathname === '/about' ? 'active' : ''}`} href={{ pathname: '/about' }}>About</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/products' ? 'active' : ''}`} href={{ pathname: '/products' }}>Products</Link>
            </li>
            <li>
                <Link className={`link ${pathname === '/customercare' ? 'active' : ''}`} href={{ pathname: '/customercare' }}>Customer Care</Link>
            </li>
        </ul>

    </nav>

}

src/app/layout.js
import { Inter } from "next/font/google";
import { Links } from "./components/NavBar";


const inter = Inter({ subsets: ["latin"] });

export const metadata = {
    title: "Create Next App",
    description: "Generated by create next app",
};

export default function RootLayout({ children }) {


    return (
        <html lang="en">
            <body className={inter.className}>
                <div id="header">
                    <h1>Header</h1>
                    <hr />
                    {/* Nav Bar */}
                    <Links />
                </div>
                {children}
                <div id="footer">
                    <h3>footer</h3>
                </div>
            </body>
        </html>
    );
}

Note: 
Rest of the pages are remain same.
....................................................................................
				 useRouter Hook
...................................................................................

useRouter hook allows you programmetically change route from client components.

src/app/components/DashboardNavigator.jsx

'use client'

import { useRouter } from "next/navigation"

export function DashBoardNavigator() {
    const router = useRouter()
    return <>
        <button onClick={() => {
            router.push('/dashboard')
        }}>GoToDasbhoard</button>
    </>
}


src/app/page.js
import { DashBoardNavigator } from "./components/Dashboard";


export default function HomePage(){
  return <div>
        <h1>Home Page</h1>
        <DashBoardNavigator/>
  </div>
}

src/app/dashboard/page.js
export default function DashboardPage(){
    return <div>
        <h2>Welcome to Dashboard</h2>
    </div>
}

..............................................................................................
			Advanced Routes - Dynamic Routes

What is Dynamic Route?
   When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.

/users
/users/1
/posts/comments/1
	
How to create dynamic route?

Convention:
   A dynamic segment can be created by wrapping a folder's name in square brackets.
  [folderName]
   eg:
     [id] or [city] or [slug]
					





G:\IBM\2025\June\NextJs>npx create-next-app@latest
√ What is your project named? ... dynamic-routes
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like your code inside a `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to use Turbopack for `next dev`? ... No / Yes
√ Would you like to customize the import alias (`@/*` by default)? ... No / Yes
√ What import alias would you like configured? ... @/*
Creating a new Next.js app in G:\IBM\2025\June\NextJs\dynamic-routes.


.....................................................................................
			 Building Master detail page
.....................................................................................

Ways to build:
1.Using mock data
2.Using api call


Using Mock data:

src/app/todos/page.js
// import { TODOS } from "../mock-data/todos";
import { TODOS } from "@/app/mock-data/todos" //import alise

import Link from "next/link";

export default function TodosPage() {
    return <div>
        <ul>
            {
                TODOS.map(todo => {
                    return <li key={todo.id}><span>
                        <Link href={`/todos/${todo.id}`}>{todo.title}</Link>
                    </span></li>

                })
            }
        </ul>
    </div>
}

src/app/todos/[id]/page.js

import { TODOS } from "@/app/mock-data/todos"

export default async function TodosDetailsPage(props) {
    const todosId = await props.params.id
    const todo = TODOS.find(todo => todo.id == todosId)
    return <div>
        <h1> {todosId} details</h1>
        <h2>{todo.title}</h2>
        <h3>{todo.status ? 'done' : 'not done'}</h3>

    </div>
}
............................................................................................................................................................



